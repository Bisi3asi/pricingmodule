#include "ql/cashflows/fixedratecoupon.hpp"

FixedRateBondCustom::FixedRateBondCustom(Natural settlementDays,
                                         Real faceAmount,
                                         Schedule schedule,
                                         const std::vector<Rate>& coupons,
                                         const DayCounter& accrualDayCounter,
                                         BusinessDayConvention paymentConvention,
                                         Integer paymentLag,
                                         Real redemption,
                                         const Date& issueDate,
                                         const Calendar& paymentCalendar,
                                         const Period& exCouponPeriod,
                                         const Calendar& exCouponCalendar,
                                         const BusinessDayConvention exCouponConvention,
                                         bool exCouponEndOfMonth,
                                         const DayCounter& firstPeriodDayCounter)
        : Bond(settlementDays,
               paymentCalendar==Calendar() ? schedule.calendar() : paymentCalendar,
               issueDate),
          frequency_(schedule.hasTenor() ? schedule.tenor().frequency() : NoFrequency),
          dayCounter_(accrualDayCounter),
          firstPeriodDayCounter_(firstPeriodDayCounter) {

    maturityDate_ = schedule.endDate();

    cashflows_ = FixedRateLeg(std::move(schedule))
            .withNotionals(faceAmount)
            .withCouponRates(coupons, accrualDayCounter)
            .withFirstPeriodDayCounter(firstPeriodDayCounter)
            .withPaymentCalendar(calendar_)
            .withPaymentAdjustment(paymentConvention)
            .withPaymentLag(paymentLag)
            .withExCouponPeriod(exCouponPeriod,
                                exCouponCalendar,
                                exCouponConvention,
                                exCouponEndOfMonth);

    addRedemptionsToCashflows(std::vector<Real>(1, redemption));

    QL_ENSURE(!cashflows().empty(), "bond with no cashflows!");
    QL_ENSURE(redemptions_.size() == 1, "multiple redemptions created");
}



double pricingFRB(
        // ===================================================================================================
        const int evaluationDate                // INPUT 1. 평가일 (serial number)
        , const int issueDate                   // INPUT 3. 발행일 (serial number)
        , const int maturityDate                // INPUT 4. 만기일 (serial number)
        , const double notional                 // INPUT 5. 채권 원금
        , const double couponRate               // INPUT 6. 쿠폰 이율
        , const int couponDayCounter            // INPUT 7. DayCounter code (TODO)
        , const int couponCalendar              // INPUT 8. (추가)Calendar code (TODO)
        , const int couponFrequency             // INPUT 9. (추가)Frequency code (TODO)
        , const int scheduleGenRule             // INPUT 10. 스케쥴 생성 기준(Forward/Backward)
        , const int paymentBDC                  // INPUT 11. 지급일 휴일 적용 기준
        , const int paymentLag                  // INPUT 12. 지급일 지연 일 수

        , const int numberOfCoupons             // INPUT 13. 쿠폰 개수
        , const int* paymentDates               // INPUT 14. 지급일 배열
        , const int* realStartDates             // INPUT 15. 각 구간 시작일
        , const int* realEndDates               // INPUT 16. 각 구간 종료일

        , const int numberOfGirrTenors          // INPUT 17. GIRR 만기 수
        , const int* girrTenorDays              // INPUT 18. GIRR 만기 (startDate로부터의 일수)
        , const double* girrRates               // INPUT 19. GIRR 금리
        , const int* girrConvention             // INPUT 20. GIRR DayCountern, 보간법, 이자 계산 방식, 이자 빈도 (TODO)

        , const double spreadOverYield          // INPUT 21. 채권의 종목 Credit Spread

        , const int numberOfCsrTenors           // INPUT 24. CSR 만기 수
        , const int* csrTenorDays               // INPUT 25. CSR 만기 (startDate로부터의 일수)
        , const double* csrRates                // INPUT 26. CSR 스프레드 (금리 차이)

        , const double marketPrice              // INPUT 27. (추가)시장가격(Spread Over Yield 산출 시 사용)
        , const double csrRiskWeight            // INPUT 28. (추가)csr 리스크요소 버킷의 위험 가중치(Curvature 산출 시 사용)

        , const int calType			            // INPUT 29. 계산 타입 (1: Price, 2. BASEL 2 민감도, 3. BASEL 3 민감도, 9: SOY)
        , const int logYn                       // INPUT 30. 로그 파일 생성 여부 (0: No, 1: Yes)

        // OUTPUT 1. Net PV (리턴값)
        , double* resultBasel2                  // OUTPUT 2. (추가)Basel 2 Result(Delta, Gamma, Duration, Convexity, PV01)
        , double* resultGirrDelta               // OUTPUT 3. GIRR Delta [index 0: size, index 1 ~ size + 1: tenor, index size + 2 ~ 2 * size + 1: sensitivity]
        , double* resultCsrDelta			    // OUTPUT 4. CSR Delta [index 0: size, index 1 ~ size + 1: tenor, index size + 2 ~ 2 * size + 1: sensitivity]
        , double* resultGirrCvr			        // OUTPUT 5. (추가)GIRR Curvature [BumpUp Curvature, BumpDownCurvature]
        , double* resultCsrCvr			        // OUTPUT 6. (추가)CSR Curvature [BumpUp Curvature, BumpDownCurvature]
        // ===================================================================================================
) {
/* TODO / NOTE */
// 1. DayCounter, Frequency 등 QuantLib Class Get 함수 정의 필요

/* 로거 초기화 */
//    disableConsoleLogging();    // 로깅여부 N일시 콘촐 입출력 비활성화
//    if (logYn == 1) {
//        initLogger("bond.log"); // 생성 파일명 지정
//    }

//    info("==============[Bond: pricingFRB Logging Started!]==============");
// INPUT 데이터 로깅
//    printAllInputDataFRB(evaluationDate,
//                         settlementDays,
//                         issueDate,
//                         maturityDate,
//                         notional,
//                         couponRate,
//                         couponDayCounter,
//                         numberOfCoupons,
//                         paymentDates,
//                         realStartDates,
//                         realEndDates,
//                         numberOfGirrTenors,
//                         girrTenorDays,
//                         girrRates,
//                         girrDayCounter,
//                         girrInterpolator,
//                         girrCompounding,
//                         girrFrequency,
//                         spreadOverYield,
//                         spreadOverYieldCompounding,
//                         spreadOverYieldDayCounter,
//                         numberOfCsrTenors,
//                         csrTenorDays,
//                         csrRates,
//                         calType
//    );

    if (calType != 1 && calType!= 2 && calType != 3 && calType != 9) {
//        error("[princingFRB]: Invalid calculation type. Only 1, 2, 3, 9 are supported.");
        return -1; // Invalid calculation type
    }

// 결과 데이터 초기화
    initResult(resultBasel2, 50);
    initResult(resultGirrDelta, 50);
    initResult(resultCsrDelta, 50);
    initResult(resultGirrCvr, 50);
    initResult(resultCsrCvr, 50);

// revaluationDateSerial -> revaluationDate
    Date asOfDate_ = Date(evaluationDate);
    const Date issueDate_ = Date(issueDate);

// 전역 Settings에 평가일을 설정 (이후 모든 계산에 이 날짜 기준 적용)
    Settings::instance().evaluationDate() = asOfDate_;
    Size settlementDays_ = 0;

    Real notional_ = notional;

// 고정 쿠폰율 벡터 생성
    std::vector<Rate> couponRate_ = std::vector<Rate>(1, couponRate);

// 쿠폰 이자 계산을 위한 일수계산 방식 설정
    DayCounter couponDayCounter_ = ActualActual(ActualActual::ISDA); // TODO 변환 함수 적용 (DayCounter)

// GIRR 커브 구성용 날짜 및 금리 벡터
    std::vector<Date> girrDates_;
    std::vector<Real> girrRates_;

// GIRR 커브의 주요 기간 설정 (시장 표준 테너)
    std::vector<Period> girrPeriod = { Period(3, Months), Period(6, Months), Period(1, Years), Period(2, Years),
                                       Period(3, Years), Period(5, Years), Period(10, Years), Period(15, Years),
                                       Period(20, Years), Period(30, Years) };

// GIRR 커브 시작점 (revaluationDate 기준) 입력
    girrDates_.emplace_back(asOfDate_);
    girrRates_.emplace_back(girrRates[0]);

// 나머지 GIRR 커브 구성 요소 입력
    for (Size dateNum = 0; dateNum < numberOfGirrTenors; ++dateNum) {
        girrDates_.emplace_back(asOfDate_ + girrPeriod[dateNum]);
        girrRates_.emplace_back(girrRates[dateNum]);
    }

// GIRR 커브 계산 사용 추가 요소
    DayCounter girrDayCounter_ = Actual365Fixed(); // DCB, TODO 변환 함수 적용
    Linear girrInterpolator_ = Linear(); // 보간 방식, TODO 변환 함수 적용 (Interpolator)
    Compounding girrCompounding_ = Compounding::Continuous; // 이자 계산 방식, TODO 변환 함수 적용 (Compounding)
    Frequency girrFrequency_ = Frequency::Annual; // 이자 지급 빈도, TODO 변환 함수 적용 (Frequency)

// GIRR 커브 생성
    ext::shared_ptr<YieldTermStructure> girrTermstructure = ext::make_shared<ZeroCurve>(girrDates_, girrRates_,
                                                                                        girrDayCounter_, girrInterpolator_, girrCompounding_, girrFrequency_);

// GIRR 커브를 RelinkableHandle에 연결
    RelinkableHandle<YieldTermStructure> girrCurve;
    girrCurve.linkTo(girrTermstructure);

// spreadOverYiled 값을 interest Rate 객체로 래핑 (CSR 계산용)
    double tmpSpreadOverYield = spreadOverYield;
    Compounding spreadOverYieldCompounding_ = Compounding::Continuous; // 이자 계산 방식, TODO 변환 함수 적용 (Compounding)
    DayCounter spreadOverYieldDayCounter_ = Actual365Fixed();  // DCB, TODO 변환 함수 적용 (DayCounter)
    InterestRate tempRate(tmpSpreadOverYield, spreadOverYieldDayCounter_, spreadOverYieldCompounding_, Frequency::Annual);

// CSR 커브 구성용 날짜 및 금리 벡터
    std::vector<Date> csrDates_;
    std::vector<Period> csrPeriod = { Period(6, Months), Period(1, Years), Period(3, Years), Period(5, Years), Period(10, Years) };

// CSR 커브 시작점 (revaluationDate 기준) 입력
    csrDates_.emplace_back(asOfDate_);

// CSR 스프레드를 담을 핸들 벡터
    std::vector<Handle<Quote>> csrSpreads_;

// 첫번째 CSR 스프레드에 spreadOverYield 값을 설정
    double spreadOverYield_ = tempRate.equivalentRate(girrCompounding_, girrFrequency_, girrDayCounter_.yearFraction(asOfDate_, asOfDate_));
    csrSpreads_.emplace_back(ext::make_shared<SimpleQuote>(spreadOverYield_));

// 나머지 CSR 커브 기간별 스프레드 입력
    for (Size dateNum = 0; dateNum < numberOfCsrTenors; ++dateNum) {
        csrDates_.emplace_back(asOfDate_ + csrPeriod[dateNum]);
        spreadOverYield_ = tempRate.equivalentRate(girrCompounding_, girrFrequency_, girrDayCounter_.yearFraction(asOfDate_, csrDates_.back()));
        csrSpreads_.emplace_back(ext::make_shared<SimpleQuote>(csrRates[dateNum] + spreadOverYield_));
    }

// GIRR + CSR 스프레드 커브 생성
    ext::shared_ptr<ZeroYieldStructure> discountingTermStructure = ext::make_shared<PiecewiseZeroSpreadedTermStructure>(girrCurve, csrSpreads_, csrDates_);

// Discounting 커브 연결
    RelinkableHandle<YieldTermStructure> discountingCurve;
    discountingCurve.linkTo(discountingTermStructure);

// Discounting 엔진 생성 (채권 가격 계산용)
    auto bondEngine = ext::make_shared<DiscountingBondEngine>(discountingCurve);

// Schedule 객체 생성 (지급일)
    Schedule fixedBondSchedule_;

// Coupon Schedule 생성
    if (numberOfCoupons > 0) { // 쿠폰 스케줄이 인자로 들어오는 경우
//        info("[Coupon Schedule]: PARAMETER INPUT");

        std::vector<Date> couponSch_;
        couponSch_.emplace_back(realStartDates[0]);
        for (Size schNum = 0; schNum < numberOfCoupons; ++schNum) {
            couponSch_.emplace_back(realEndDates[schNum]);
        }
        fixedBondSchedule_ = Schedule(couponSch_);
    }

    else {  // 쿠폰 스케줄이 인자로 들어오지 않는 경우, 스케줄을 직접 생성
//        info("[Coupon Schedule]: GENERATED BY MODULE");

        Date effectiveDate = Date(realStartDates[0]); // 쿠폰 첫번째 시작일로 수정
        //Date effectiveDate = Date(issueDate); // 기존 코드
        Calendar couponCalendar_ = SouthKorea();
        Frequency couponFrequency_ = Frequency::Semiannual; // Period(Tenor)형태도 가능
        DateGeneration::Rule genRule = DateGeneration::Backward;
        BusinessDayConvention couponBDC = Following;


        fixedBondSchedule_ = MakeSchedule().from(effectiveDate)
                .to(Date(maturityDate))
                .withFrequency(couponFrequency_)
                .withCalendar(couponCalendar_)
                .withConvention(couponBDC)
                .withRule(genRule); // payment Lag는 Bond 스케쥴 생성 시 적용
    }

/* FOR DEBUG */
//    printAllData(fixedBondSchedule_);

    Integer paymentLag_ = paymentLag;
    BusinessDayConvention paymentBDC_ = ModifiedFollowing;
    Real redemptionRatio = 100.0;
// FixedRateBond 객체 생성
    Calendar couponCalendar_ = NullCalendar(); // TODO 변환 함수 적용(Calendar)
    FixedRateBondCustom fixedRateBond(
                settlementDays_,
                notional_,
                fixedBondSchedule_,
                couponRate_,
                couponDayCounter_,
                paymentBDC_, // Business Day Convention, TODO 변환 함수 적용 (DayConvention)
                paymentLag_,
                redemptionRatio,
                issueDate_,
                couponCalendar_);

    if (calType == 9) {
        // Calc Spread Over Yield
        std::vector<Handle<Quote>> tmpCsrSpreads_;
        tmpCsrSpreads_.emplace_back(ext::make_shared<SimpleQuote>(0.0));
        for (Size dateNum = 0; dateNum < numberOfCsrTenors; ++dateNum) {
            tmpCsrSpreads_.emplace_back(ext::make_shared<SimpleQuote>(csrRates[dateNum]));
        }
        ext::shared_ptr<ZeroYieldStructure> tmpDiscountingTermStructure =
                ext::make_shared<PiecewiseZeroSpreadedTermStructure>(girrCurve, tmpCsrSpreads_, csrDates_);
        RelinkableHandle<YieldTermStructure> tmpDiscountingCurve;
        tmpDiscountingCurve.linkTo(tmpDiscountingTermStructure);
        auto tmpBondEngine = ext::make_shared<DiscountingBondEngine>(tmpDiscountingCurve);
        fixedRateBond.setPricingEngine(tmpBondEngine);
        // SettlementDays 관행 무시(Algo
        Real soy = CashFlows::zSpread(fixedRateBond.cashflows(), marketPrice, *tmpDiscountingCurve, Actual365Fixed(), Continuous, Annual,
                                      false, asOfDate_, couponCalendar_.advance(asOfDate_, Period(settlementDays_, Days)), 1.0e-10, 100, 0.005);
//        Real soy = CashFlows::zSpread(fixedRateBond.cashflows(), marketPrice, *tmpDiscountingCurve, Actual365Fixed(), Continuous, Annual,
//                                      false, asOfDate_, couponCalendar.advance(asOfDate_, Period(settlementDays, Days)), 1.0e-10, 100, 0.005);

        return soy;
    }
// Fixed Rate Bond에 Discounting 엔진 연결
    fixedRateBond.setPricingEngine(bondEngine);

// 채권 가격 Net PV 계산
    Real npv = fixedRateBond.NPV();

// 이론가 산출의 경우 GIRR Delta 산출을 하지 않음
    if (calType == 1) {
        // OUTPUT 데이터 로깅
//        printAllOutputDataFRB(npv, resultGirrDelta, resultCsrDelta);
        /* OUTPUT 1. Net PV 리턴 */
//        info("==============[Bond: pricingFRB Logging Ended!]==============");
        return npv;
    }

    if (calType == 2) {
        // Delta 계산
        Real bumpSize = 0.0001; // bumpSize를 0.0001 이외의 값으로 적용 시, PV01 산출을 독립적으로 구현해줘야 함
        std::vector<Real> bumpGearings{1.0, -1.0};
        std::vector<Real> bumpedNpv(bumpGearings.size(), 0.0);
        for (Size bumpNo = 0; bumpNo < bumpGearings.size(); ++bumpNo) {
            std::vector<Rate> bumpGirrRates = girrRates_;
            for (Size bumpTenorNum = 0; bumpTenorNum < girrRates_.size(); ++bumpTenorNum) {
                // GIRR 커브의 금리를 bumping (1bp 상승)
                bumpGirrRates[bumpTenorNum] += bumpGearings[bumpNo] * bumpSize;
            }

            // bump된 금리로 새로운 ZeroCurve 생성
            ext::shared_ptr<YieldTermStructure> bumpGirrTermstructure = ext::make_shared<ZeroCurve>(girrDates_, bumpGirrRates, girrDayCounter_, girrInterpolator_,
                                                                                                    girrCompounding_, girrFrequency_);

            // RelinkableHandle에 bump된 커브 연결
            RelinkableHandle<YieldTermStructure> bumpGirrCurve;
            bumpGirrCurve.linkTo(bumpGirrTermstructure);

            // CSR Spread를 적용한 bump GIRR 기반 할인 커브 생성
            ext::shared_ptr<ZeroYieldStructure> bumpDiscountingTermStructure = ext::make_shared<PiecewiseZeroSpreadedTermStructure>(bumpGirrCurve, csrSpreads_, csrDates_);

            // 할인 커브를 RelinkableHandle로 wrapping
            RelinkableHandle<YieldTermStructure> bumpDiscountingCurve;
            bumpDiscountingCurve.linkTo(bumpDiscountingTermStructure);
            bumpDiscountingCurve->enableExtrapolation(); // 외삽 허용

            // discountingCurve로 새로운 pricing engine 생성
            auto bumpBondEngine = ext::make_shared<DiscountingBondEngine>(bumpDiscountingCurve);

            // FixedRateBond에 bump된 pricing engine 연결
            fixedRateBond.setPricingEngine(bumpBondEngine);

            // 기존 Net PV - bump된 Net PV 계산 (GIRR Delta)
            bumpedNpv[bumpNo] = fixedRateBond.NPV();

        }

        QL_REQUIRE(bumpedNpv.size() > 1, "Failed to calculate bumpedNPV.");
        Real delta = (bumpedNpv[0] - npv) / bumpSize;
        Real gamma = (bumpedNpv[0] - 2.0 * npv + bumpedNpv[1]) / (bumpSize * bumpSize);

        const DayCounter& ytmDayCounter = Actual365Fixed();
        Compounding ytmCompounding = Continuous;
        Frequency ytmFrequency = Annual;
        Rate ytmValue = CashFlows::yield(fixedRateBond.cashflows(), npv, ytmDayCounter, ytmCompounding, ytmFrequency, false,
                                    couponCalendar_.advance(asOfDate_, Period(settlementDays_, Days)), asOfDate_,
                                    1.0e-15, 100, 0.005);
        InterestRate ytm = InterestRate(ytmValue, ytmDayCounter, ytmCompounding, ytmFrequency);

        // Duration 계산
        Duration::Type durationType = Duration::Modified;
        Real duration = CashFlows::duration(fixedRateBond.cashflows(), ytm, durationType, false,
                                            couponCalendar_.advance(asOfDate_, Period(settlementDays_, Days)), asOfDate_);

        Real convexity = CashFlows::convexity(fixedRateBond.cashflows(), ytm, false,
                                              couponCalendar_.advance(asOfDate_, Period(settlementDays_, Days)), asOfDate_);

        Real PV01 = delta * bumpSize;

        resultBasel2[0] = delta;
        resultBasel2[1] = gamma;
        resultBasel2[2] = duration;
        resultBasel2[3] = convexity;
        resultBasel2[4] = PV01;

        return npv;
    }

    if (calType == 3) {
        // GIRR Bump Rate 설정
        Real girrBump = 0.0001;

        // GIRR Delta 적재용 벡터 생성
        std::vector<Real> disCountingGirr;

        // GIRR Delta 계산
        for (Size bumpNum = 1; bumpNum < girrRates_.size(); ++bumpNum) {
            // GIRR 커브의 금리를 bumping (1bp 상승)
            std::vector<Rate> bumpGirrRates = girrRates_;
            bumpGirrRates[bumpNum] += girrBump;

            // bump된 금리로 새로운 ZeroCurve 생성
            ext::shared_ptr<YieldTermStructure> bumpGirrTermstructure = ext::make_shared<ZeroCurve>(girrDates_, bumpGirrRates, girrDayCounter_, girrInterpolator_, girrCompounding_, girrFrequency_);

            // RelinkableHandle에 bump된 커브 연결
            RelinkableHandle<YieldTermStructure> bumpGirrCurve;
            bumpGirrCurve.linkTo(bumpGirrTermstructure);

            // CSR Spread를 적용한 bump GIRR 기반 할인 커브 생성
            ext::shared_ptr<ZeroYieldStructure> bumpDiscountingTermStructure = ext::make_shared<PiecewiseZeroSpreadedTermStructure>(bumpGirrCurve, csrSpreads_, csrDates_);

            // 할인 커브를 RelinkableHandle로 wrapping
            RelinkableHandle<YieldTermStructure> bumpDiscountingCurve;
            bumpDiscountingCurve.linkTo(bumpDiscountingTermStructure);
            bumpDiscountingCurve->enableExtrapolation(); // 외삽 허용

            // discountingCurve로 새로운 pricing engine 생성
            auto bumpBondEngine = ext::make_shared<DiscountingBondEngine>(bumpDiscountingCurve);

            // FixedRateBond에 bump된 pricing engine 연결
            fixedRateBond.setPricingEngine(bumpBondEngine);

            // 기존 Net PV - bump된 Net PV 계산 (GIRR Delta)
            Real tmpGirr = (fixedRateBond.NPV() - npv) * 10000;

            // 산출된 Girr Delta 값을 벡터에 추가
            disCountingGirr.emplace_back(tmpGirr);
        }

        /* OUTPUT 2. GIRR Delta 결과 적재 */
        std::vector<Real> girrTenor = { 0.25, 0.5, 1.0, 2.0, 3.0, 5.0, 10.0, 15.0, 20.0, 30.0 };
        Size girrDataSize = girrTenor.size();
        // 0인 민감도를 제외하고 적재
        processResultArray(girrTenor, disCountingGirr, girrDataSize, resultGirrDelta);

        // CSR Bump Rate 설정
        Real csrBump = 0.0001;

        // CSR Delta 적재용 벡터 생성
        std::vector<Real> disCountingCsr;

        // CSR Delta 계산
        for (Size bumpNum = 1; bumpNum < csrSpreads_.size(); ++bumpNum) {
            // bump된 CSR Spread 벡터 초기화
            std::vector<Handle<Quote>> bumpCsrSpreads_;

            // 첫번째 spread 항목은 조건부로 bump 적용 (벤치마크 sparead curve에 대해 하나의 bump만 적용)
            if (bumpNum == 1) {
                bumpCsrSpreads_.emplace_back(ext::make_shared<SimpleQuote>(csrSpreads_[0]->value() + csrBump));
            }
            else {
                bumpCsrSpreads_.emplace_back(ext::make_shared<SimpleQuote>(csrSpreads_[0]->value()));
            }

            // 나머지 CSR Spread 항목도 bumpNum 위치에만 bump 적용
            for (Size i = 1; i < csrSpreads_.size(); ++i) {
                Real bump = (i == bumpNum) ? csrBump : 0.0;
                bumpCsrSpreads_.emplace_back(ext::make_shared<SimpleQuote>(csrSpreads_[i]->value() + bump));
            }

            // GIRR 커브에 bump된 CSR Spread를 적용한 할인 커브 생성
            ext::shared_ptr<ZeroYieldStructure> bumpDiscountingTermStructure = ext::make_shared<PiecewiseZeroSpreadedTermStructure>(girrCurve, bumpCsrSpreads_, csrDates_);

            // 새로운 할인 커브를 RelinkableHandle로 wrapping
            RelinkableHandle<YieldTermStructure> bumpDiscountingCurve;
            bumpDiscountingCurve.linkTo(bumpDiscountingTermStructure);
            bumpDiscountingCurve->enableExtrapolation(); // 외삽 허용

            // discountingCurve로 새로운 pricing engine 생성
            auto bumpBondEngine = ext::make_shared<DiscountingBondEngine>(bumpDiscountingCurve);

            // FixedRateBond에 bump된 pricing engine 연결
            fixedRateBond.setPricingEngine(bumpBondEngine);

            // 기존 Net PV - bump된 Net PV 계산 (CSR Delta)
            Real tmpCsr = (fixedRateBond.NPV() - npv) * 10000;

            // 산출된 CSR Delta 값을 벡터에 추가
            disCountingCsr.emplace_back(tmpCsr);
        }

        /* OUTPUT 3. CSR Delta 결과 적재 */
        std::vector<Real> csrTenor = { 0.5, 1.0, 3.0, 5.0, 10.0 };
        Size csrDataSize = csrTenor.size();
        // 0인 민감도를 제외하고 적재
        processResultArray(csrTenor, disCountingCsr, csrDataSize, resultCsrDelta);


        Real totalGirr = 0;
        for (const auto& girr : disCountingGirr) {
            totalGirr += girr;
        }

        // Curvature 계산
        Real curvatureRW = 0.017; // bumpSize를 FRTB 기준서의 Girr Curvature RiskWeight로 설정
        std::vector<Real> bumpGearings{1.0, -1.0};
        std::vector<Real> bumpedNpv(bumpGearings.size(), 0.0);
        for (Size bumpNo = 0; bumpNo < bumpGearings.size(); ++bumpNo) {
            std::vector<Rate> bumpGirrRates = girrRates_;
            for (Size bumpTenorNum = 0; bumpTenorNum < girrRates_.size(); ++bumpTenorNum) {
                // GIRR 커브의 금리를 bumping (RiskWeight 만큼 상승)
                bumpGirrRates[bumpTenorNum] += bumpGearings[bumpNo] * curvatureRW;
            }

            // bump된 금리로 새로운 ZeroCurve 생성
            ext::shared_ptr<YieldTermStructure> bumpGirrTermstructure = ext::make_shared<ZeroCurve>(girrDates_, bumpGirrRates, girrDayCounter_, girrInterpolator_,
                                                                                                    girrCompounding_, girrFrequency_);

            // RelinkableHandle에 bump된 커브 연결
            RelinkableHandle<YieldTermStructure> bumpGirrCurve;
            bumpGirrCurve.linkTo(bumpGirrTermstructure);

            // CSR Spread를 적용한 bump GIRR 기반 할인 커브 생성
            ext::shared_ptr<ZeroYieldStructure> bumpDiscountingTermStructure = ext::make_shared<PiecewiseZeroSpreadedTermStructure>(bumpGirrCurve, csrSpreads_, csrDates_);

            // 할인 커브를 RelinkableHandle로 wrapping
            RelinkableHandle<YieldTermStructure> bumpDiscountingCurve;
            bumpDiscountingCurve.linkTo(bumpDiscountingTermStructure);
            bumpDiscountingCurve->enableExtrapolation(); // 외삽 허용

            // discountingCurve로 새로운 pricing engine 생성
            auto bumpBondEngine = ext::make_shared<DiscountingBondEngine>(bumpDiscountingCurve);

            // FixedRateBond에 bump된 pricing engine 연결
            fixedRateBond.setPricingEngine(bumpBondEngine);

            // 기존 Net PV - bump된 Net PV 계산 (GIRR Delta)
            bumpedNpv[bumpNo] = fixedRateBond.NPV();
        }

        QL_REQUIRE(bumpedNpv.size() > 1, "Failed to calculate bumpedNPV.");
        resultGirrCvr[0] = (bumpedNpv[0] - npv - curvatureRW * totalGirr);
        resultGirrCvr[1] = (bumpedNpv[1] - npv + curvatureRW * totalGirr);

        Real totalCsr = 0;
        for (const auto& csr : disCountingCsr) {
            totalCsr += csr;
        }

        // Curvature 계산
        curvatureRW = csrRiskWeight; // bumpSize를 FRTB 기준서의 CSR Bucket의 Curvature RiskWeight로 설정
        for (Size bumpNo = 0; bumpNo < bumpGearings.size(); ++bumpNo) {
            std::vector<Handle<Quote>> bumpCsrSpreads_;
            for (Size bumpTenorNum = 0; bumpTenorNum < csrSpreads_.size(); ++bumpTenorNum) {
                // Csr 커브의 금리를 bumping (RiskWeight 만큼 상승)
                bumpCsrSpreads_.emplace_back(ext::make_shared<SimpleQuote>(csrSpreads_[bumpTenorNum]->value() +
                                                                            bumpGearings[bumpNo] * curvatureRW));
            }

            // GIRR 커브에 bump된 CSR Spread를 적용한 할인 커브 생성
            ext::shared_ptr<ZeroYieldStructure> bumpDiscountingTermStructure =
                    ext::make_shared<PiecewiseZeroSpreadedTermStructure>(girrCurve, bumpCsrSpreads_, csrDates_);

            // 새로운 할인 커브를 RelinkableHandle로 wrapping
            RelinkableHandle<YieldTermStructure> bumpDiscountingCurve;
            bumpDiscountingCurve.linkTo(bumpDiscountingTermStructure);
            bumpDiscountingCurve->enableExtrapolation(); // 외삽 허용


            // discountingCurve로 새로운 pricing engine 생성
            auto bumpBondEngine = ext::make_shared<DiscountingBondEngine>(bumpDiscountingCurve);

            // FixedRateBond에 bump된 pricing engine 연결
            fixedRateBond.setPricingEngine(bumpBondEngine);

            // 기존 Net PV - bump된 Net PV 계산 (GIRR Delta)
            bumpedNpv[bumpNo] = fixedRateBond.NPV();
        }

        QL_REQUIRE(bumpedNpv.size() > 1, "Failed to calculate bumpedNPV.");
        resultCsrCvr[0] = (bumpedNpv[0] - npv - curvatureRW * totalCsr);
        resultCsrCvr[1] = (bumpedNpv[1] - npv + curvatureRW * totalCsr);

        /* OUTPUT 1. Net PV 리턴 */
        return npv;
    }

// NPV : clean, dirty, accured Interest
    Real cleanPrice = fixedRateBond.cleanPrice() / 100.0 * notional;
    Real dirtyPrice = fixedRateBond.dirtyPrice() / 100.0 * notional;
    Real accruedInterest = fixedRateBond.accruedAmount() / 100.0 * notional;

//    printAllOutputDataFRB(npv, resultGirrDelta, resultCsrDelta);
//    info("==============[Bond: pricingFRB Logging Ended!]==============");

/* OUTPUT 1. Net PV 리턴 */
    return npv;
}