double pricingZeroCouponLeg(
        // ===================================================================================================
        const int evaluationDate                // INPUT 1. 평가일 (serial number)
        , const int issueDate                   // INPUT 2. 발행일 (serial number)
        , const int maturityDate                // INPUT 3. 만기일 (serial number)
        , const double notional                 // INPUT 4. 채권 원금

        , const int numberOfGirrTenors          // INPUT 5. GIRR 만기 수
        , const int* girrTenorDays              // INPUT 6. GIRR 만기 (startDate로부터의 일수)
        , const double* girrRates               // INPUT 7. GIRR 금리
        , const int* girrConvention             // INPUT 8. GIRR DayCountern, 보간법, 이자 계산 방식, 이자 빈도 (TODO)

        , const double girrRiskWeight           // INPUT 9. (추가)girr 리스크요소 버킷의 위험 가중치(Curvature 산출 시 사용)

        , const int calType			            // INPUT 10. 계산 타입 (1: Price, 2. BASEL 2 민감도, 3. BASEL 3 민감도)
        , const int logYn                       // INPUT 11. 로그 파일 생성 여부 (0: No, 1: Yes)

        // OUTPUT 1. Net PV (리턴값)
        , double* resultBasel2                  // OUTPUT 2. (추가)Basel 2 Result(Delta, Gamma, Duration, Convexity, PV01)
        , double* resultGirrDelta               // OUTPUT 3. GIRR Delta [index 0: size, index 1 ~ size + 1: tenor, index size + 2 ~ 2 * size + 1: sensitivity]
        , double* resultGirrCvr			        // OUTPUT 5. (추가)GIRR Curvature [BumpUp Curvature, BumpDownCurvature]
        // ===================================================================================================

) {

    if (calType != 1 && calType!= 2 && calType != 3) {
//        error("[princingFRB]: Invalid calculation type. Only 1, 2, 3 are supported.");
        return -1; // Invalid calculation type
    }

    // 결과 데이터 초기화
    initResult(resultBasel2, 50);
    initResult(resultGirrDelta, 50);
    initResult(resultGirrCvr, 50);

    // revaluationDateSerial -> revaluationDate
    Date asOfDate_ = Date(evaluationDate);
    const Date issueDate_ = Date(issueDate);
    const Date maturityDate_ = Date(maturityDate);

    // 전역 Settings에 평가일을 설정 (이후 모든 계산에 이 날짜 기준 적용)
    Settings::instance().evaluationDate() = asOfDate_;
    Integer settlementDays_ = 0;

    Real notional_ = notional;


    // GIRR 커브 구성용 날짜 및 금리 벡터
    std::vector<Date> girrDates_;
    std::vector<Real> girrRates_;

    // GIRR 커브의 주요 기간 설정 (시장 표준 테너)
    std::vector<Period> girrPeriod = { Period(3, Months), Period(6, Months), Period(1, Years), Period(2, Years),
                                       Period(3, Years), Period(5, Years), Period(10, Years), Period(15, Years),
                                       Period(20, Years), Period(30, Years) };

    // GIRR 커브 시작점 (revaluationDate 기준) 입력
    girrDates_.emplace_back(asOfDate_);
    girrRates_.emplace_back(girrRates[0]);

    // 나머지 GIRR 커브 구성 요소 입력
    for (Size dateNum = 0; dateNum < numberOfGirrTenors; ++dateNum) {
        girrDates_.emplace_back(asOfDate_ + girrPeriod[dateNum]);
        girrRates_.emplace_back(girrRates[dateNum]);
    }

    // GIRR 커브 계산 사용 추가 요소
    DayCounter girrDayCounter_ = Actual365Fixed(); // DCB, TODO 변환 함수 적용
    Linear girrInterpolator_ = Linear(); // 보간 방식, TODO 변환 함수 적용 (Interpolator)
    Compounding girrCompounding_ = Compounding::Continuous; // 이자 계산 방식, TODO 변환 함수 적용 (Compounding)
    Frequency girrFrequency_ = Frequency::Annual; // 이자 지급 빈도, TODO 변환 함수 적용 (Frequency)

    // GIRR 커브 생성
    ext::shared_ptr<YieldTermStructure> girrTermstructure = ext::make_shared<ZeroCurve>(girrDates_, girrRates_,
                                                                                        girrDayCounter_, girrInterpolator_, girrCompounding_, girrFrequency_);

    // GIRR 커브를 RelinkableHandle에 연결
    RelinkableHandle<YieldTermStructure> girrCurve;
    girrCurve.linkTo(girrTermstructure);


    // Discounting 엔진 생성 (채권 가격 계산용)
    auto bondEngine = ext::make_shared<DiscountingBondEngine>(girrCurve);


    // ZeroCouponBond 객체 생성
    Calendar couponCalendar_ = NullCalendar(); // TODO 변환 함수 적용(Calendar)
    ZeroCouponBond zeroCouponBond(
            settlementDays_,
            couponCalendar_,
            notional_,
            maturityDate_,
            ModifiedFollowing, // Business Day Convention, TODO 변환 함수 적용 (DayConvention)
            100.0,
            issueDate_);

    // Fixed Rate Bond에 Discounting 엔진 연결
    zeroCouponBond.setPricingEngine(bondEngine);

    // 채권 가격 Net PV 계산
    Real npv = zeroCouponBond.NPV();

    // 이론가 산출의 경우 GIRR Delta 산출을 하지 않음
    if (calType == 1) {
        // OUTPUT 데이터 로깅
//        printAllOutputDataFRB(npv, resultGirrDelta, resultCsrDelta);
        /* OUTPUT 1. Net PV 리턴 */
//        info("==============[Bond: pricingFRB Logging Ended!]==============");
        return npv;
    }

    if (calType == 2) {
        // Delta 계산
        Real bumpSize = 0.0001; // bumpSize를 0.0001 이외의 값으로 적용 시, PV01 산출을 독립적으로 구현해줘야 함
        std::vector<Real> bumpGearings{1.0, -1.0};
        std::vector<Real> bumpedNpv(bumpGearings.size(), 0.0);
        for (Size bumpNo = 0; bumpNo < bumpGearings.size(); ++bumpNo) {
            std::vector<Rate> bumpGirrRates = girrRates_;
            for (Size bumpTenorNum = 0; bumpTenorNum < girrRates_.size(); ++bumpTenorNum) {
                // GIRR 커브의 금리를 bumping (1bp 상승)
                bumpGirrRates[bumpTenorNum] += bumpGearings[bumpNo] * bumpSize;
            }

            // bump된 금리로 새로운 ZeroCurve 생성
            ext::shared_ptr<YieldTermStructure> bumpGirrTermstructure = ext::make_shared<ZeroCurve>(girrDates_, bumpGirrRates, girrDayCounter_, girrInterpolator_,
                                                                                                    girrCompounding_, girrFrequency_);

            // RelinkableHandle에 bump된 커브 연결
            RelinkableHandle<YieldTermStructure> bumpDiscountingCurve;
            bumpDiscountingCurve.linkTo(bumpGirrTermstructure);
            bumpDiscountingCurve->enableExtrapolation(); // 외삽 허용

            // discountingCurve로 새로운 pricing engine 생성
            auto bumpBondEngine = ext::make_shared<DiscountingBondEngine>(bumpDiscountingCurve);

            // FixedRateBond에 bump된 pricing engine 연결
            zeroCouponBond.setPricingEngine(bumpBondEngine);

            // 기존 Net PV - bump된 Net PV 계산 (GIRR Delta)
            bumpedNpv[bumpNo] = zeroCouponBond.NPV();

        }

        QL_REQUIRE(bumpedNpv.size() > 1, "Failed to calculate bumpedNPV.");
        Real delta = (bumpedNpv[0] - npv) / bumpSize;
        Real gamma = (bumpedNpv[0] - 2.0 * npv + bumpedNpv[1]) / (bumpSize * bumpSize);

        const DayCounter& ytmDayCounter = Actual365Fixed();
        Compounding ytmCompounding = Continuous;
        Frequency ytmFrequency = Annual;
        Rate ytmValue = CashFlows::yield(zeroCouponBond.cashflows(), npv, ytmDayCounter, ytmCompounding, ytmFrequency, false,
                                         couponCalendar_.advance(asOfDate_, Period(settlementDays_, Days)), asOfDate_,
                                         1.0e-15, 100, 0.005);
        InterestRate ytm = InterestRate(ytmValue, ytmDayCounter, ytmCompounding, ytmFrequency);

        // Duration 계산
        Duration::Type durationType = Duration::Modified;
        Real duration = CashFlows::duration(zeroCouponBond.cashflows(), ytm, durationType, false,
                                            couponCalendar_.advance(asOfDate_, Period(settlementDays_, Days)), asOfDate_);

        Real convexity = CashFlows::convexity(zeroCouponBond.cashflows(), ytm, false,
                                              couponCalendar_.advance(asOfDate_, Period(settlementDays_, Days)), asOfDate_);

        Real PV01 = delta * bumpSize;

        resultBasel2[0] = delta;
        resultBasel2[1] = gamma;
        resultBasel2[2] = duration;
        resultBasel2[3] = convexity;
        resultBasel2[4] = PV01;

        return npv;
    }

    if (calType == 3) {
        // GIRR Bump Rate 설정
        Real girrBump = 0.0001;

        // GIRR Delta 적재용 벡터 생성
        std::vector<Real> disCountingGirr;

        // GIRR Delta 계산
        for (Size bumpNum = 1; bumpNum < girrRates_.size(); ++bumpNum) {
            // GIRR 커브의 금리를 bumping (1bp 상승)
            std::vector<Rate> bumpGirrRates = girrRates_;
            bumpGirrRates[bumpNum] += girrBump;

            // bump된 금리로 새로운 ZeroCurve 생성
            ext::shared_ptr<YieldTermStructure> bumpGirrTermstructure = ext::make_shared<ZeroCurve>(girrDates_, bumpGirrRates, girrDayCounter_, girrInterpolator_, girrCompounding_, girrFrequency_);

            // 할인 커브를 RelinkableHandle로 wrapping
            RelinkableHandle<YieldTermStructure> bumpDiscountingCurve;
            bumpDiscountingCurve.linkTo(bumpGirrTermstructure);
            bumpDiscountingCurve->enableExtrapolation(); // 외삽 허용

            // discountingCurve로 새로운 pricing engine 생성
            auto bumpBondEngine = ext::make_shared<DiscountingBondEngine>(bumpDiscountingCurve);

            // FixedRateBond에 bump된 pricing engine 연결
            zeroCouponBond.setPricingEngine(bumpBondEngine);

            // 기존 Net PV - bump된 Net PV 계산 (GIRR Delta)
            Real tmpGirr = (zeroCouponBond.NPV() - npv) * 10000;

            // 산출된 Girr Delta 값을 벡터에 추가
            disCountingGirr.emplace_back(tmpGirr);
        }

        /* OUTPUT 2. GIRR Delta 결과 적재 */
        std::vector<Real> girrTenor = { 0.25, 0.5, 1.0, 2.0, 3.0, 5.0, 10.0, 15.0, 20.0, 30.0 };
        Size girrDataSize = girrTenor.size();
        // 0인 민감도를 제외하고 적재
        processResultArray(girrTenor, disCountingGirr, girrDataSize, resultGirrDelta);


        Real totalGirr = 0;
        for (const auto& girr : disCountingGirr) {
            totalGirr += girr;
        }

        // Curvature 계산
        Real curvatureRW = girrRiskWeight; // bumpSize를 FRTB 기준서의 Girr Curvature RiskWeight로 설정
        std::vector<Real> bumpGearings{1.0, -1.0};
        std::vector<Real> bumpedNpv(bumpGearings.size(), 0.0);
        for (Size bumpNo = 0; bumpNo < bumpGearings.size(); ++bumpNo) {
            std::vector<Rate> bumpGirrRates = girrRates_;
            for (Size bumpTenorNum = 0; bumpTenorNum < girrRates_.size(); ++bumpTenorNum) {
                // GIRR 커브의 금리를 bumping (RiskWeight 만큼 상승)
                bumpGirrRates[bumpTenorNum] += bumpGearings[bumpNo] * curvatureRW;
            }

            // bump된 금리로 새로운 ZeroCurve 생성
            ext::shared_ptr<YieldTermStructure> bumpGirrTermstructure = ext::make_shared<ZeroCurve>(girrDates_, bumpGirrRates, girrDayCounter_, girrInterpolator_,
                                                                                                    girrCompounding_, girrFrequency_);

            // 할인 커브를 RelinkableHandle로 wrapping
            RelinkableHandle<YieldTermStructure> bumpDiscountingCurve;
            bumpDiscountingCurve.linkTo(bumpGirrTermstructure);
            bumpDiscountingCurve->enableExtrapolation(); // 외삽 허용

            // discountingCurve로 새로운 pricing engine 생성
            auto bumpBondEngine = ext::make_shared<DiscountingBondEngine>(bumpDiscountingCurve);

            // FixedRateBond에 bump된 pricing engine 연결
            zeroCouponBond.setPricingEngine(bumpBondEngine);

            // 기존 Net PV - bump된 Net PV 계산 (GIRR Delta)
            bumpedNpv[bumpNo] = zeroCouponBond.NPV();
        }

        QL_REQUIRE(bumpedNpv.size() > 1, "Failed to calculate bumpedNPV.");
        resultGirrCvr[0] = (bumpedNpv[0] - npv - curvatureRW * totalGirr);
        resultGirrCvr[1] = (bumpedNpv[1] - npv + curvatureRW * totalGirr);


        /* OUTPUT 1. Net PV 리턴 */
        return npv;
    }

// NPV : clean, dirty, accured Interest
    Real cleanPrice = zeroCouponBond.cleanPrice() / 100.0 * notional;
    Real dirtyPrice = zeroCouponBond.dirtyPrice() / 100.0 * notional;
    Real accruedInterest = zeroCouponBond.accruedAmount() / 100.0 * notional;

//    printAllOutputDataFRB(npv, resultGirrDelta, resultCsrDelta);
//    info("==============[Bond: pricingFRB Logging Ended!]==============");

/* OUTPUT 1. Net PV 리턴 */
    return npv;
}
